## 01. 复杂度和简单排序算法

### 1. 异或运算

**性质1：异或基本定义**

0  ^ 0 = 0

1 ^ 1 = 0

0 ^ 1 = 1

1 ^ 0 = 1

**性质2：满足交换律和结合律**

a ^ b = b ^ a

(a ^ b) ^ c = a ^ (b ^ c)

**性质3：由上面两个性质可以推出，异或是不看顺序的，随意异或一堆数和按照顺序异或一堆数的顺序是一样的**



这里有几个异或运算的应用的题目

（1）有一个整型数组，其中有一个数字出现奇数次，其余数字全部出现偶数次，找出这个出现奇数次的数字

（2）有一个整型数组，其中有两个数字出现奇数次，其余数字全部出现偶数次，找出这个出现奇数次的数字



解题思路：

（1）设置一个初始值 eor，让这个值和数组的每一个元素做异或运算，由于异或满足交换律和结合律，所以异或顺序无关，那么可以先把所有偶数项异或，最后异或奇数项，而根据异或的定义，两个相同的数异或为 0 ，所以最终所有偶数项都相消，只留下了奇数项的这个数字

（2）首先第一步，还是和第一问一样准备一个 eor 来和数组所有的数遍历一次，假设这两个数为 x 和 y，那么这次遍历之后 eor = x ^ y，
那么接下来所要解决的就是怎么把这个 x 和 y 提出来，可以这样想：
既然 x 和 y 是两个不同的数，那么这两个数的异或一定不为 0 ，把这个数转化为二进制表示的话，也就是说最少最少存在一位，这一位为 1 ，而这就说明，这一位上的 x 和 y，一个是0， 一个是1（这样这俩数异或之后得到的值才是1），那么我现在假设 eor 的第 5 位是 1（随便假设，方便后面理解，至于怎么找到这个 1，下面会介绍），那可以把原来数组分为两堆，第一堆是第 5 位是 1 的数字，第二堆是第 5 位是 0 的数字，那么 x 和 y一定不在同一堆，一定分别在这不同的两堆中，剩余的数字（偶数次出现的）也会分布在这两堆，那么此时我再取一个 eor' 来对第一堆或者是第二堆进行异或，这里就选用第二堆吧，那么 eor' 就会等于部分偶数次出现且第 5 位为 0 的数字以及 x 或 y的异或，那么偶数次直接消掉，x 或者 y 我们就求出来了，这里假设求出了 x，好，那么 y 怎么求呢， y = eor ^ eor'，为什么，因为 eor = x ^ y，eor' = x，所以 y 也就求出来了



```python
# 第一问
def solution(arr:list[int]) -> int:
    eor = 0
    for i in arr:
        eor ^= i
    return eor
result = solution([1, 1, 3, 5, 7, 3, 7, 5, 6])
print(result)
```

```python
# 第二问
def solution(arr:list[int]) ->int:
    eor = 0
    for i in arr:
        eor ^= i
    # 上面这一步完成之后, eor = x ^ y
    # 接下来要取位为 1 的地方, 我们取最右边的 1
    rightOne = eor & (~eor + 1) # eor和其补码做与运算, 就可以求出最右边的 1
    onlyOne = 0 # 也就是上面说的 eor'
    for i in arr:
        if rightOne & i == 0: # 如果数组中的数是第二堆的（rightOne这个位置为 0）
            onlyOne ^= i
    # 完成上面的步骤之后, onlyOne 其实就是 x 或者 y中的一个了接下来求另外一个
    return onlyOne,onlyOne^eor
x, y = solution([1, 1, 2, 3, 3, 4, 4, 5, 2, 7])
print(x, y)
```



### 2. 选择排序

### 3. 冒泡排序

### 4. 插入排序